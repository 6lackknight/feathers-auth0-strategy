# FeathersJS Auth0 Authorization Middleware

[![Build Status](https://travis-ci.org/morphatic/feathers-auth0-authorize.svg?branch=master)](https://travis-ci.org/morphatic/feathers-auth0-authorize)
[![Coverage Status](https://coveralls.io/repos/github/morphatic/feathers-auth0-authorize/badge.svg?branch=master)](https://coveralls.io/github/morphatic/feathers-auth0-authorize?branch=master)
[![npm version](https://badge.fury.io/js/%40morphatic%2Ffeathers-auth0-authorize.svg)](https://www.npmjs.com/package/@morphatic/feathers-auth0-authorize)
[![GitHub license](https://img.shields.io/badge/license-MIT-blue.svg)](https://raw.githubusercontent.com/morphatic/astrologyjs/master/LICENSE)

## Who should use this middleware

This middleware is designed specifically for the following scenario:

* [FeathersJS](https://feathersjs.com/) is being used solely as a backend API server
* [Auth0](https://auth0.com/) is being used for authentication from a frontend client written with, e.g. Vue, React, or Angular
* Auth0 is configured to sign access tokens using the `RS256` algorithm (the recommended practice)

For a fuller discussion of this scenario and why I chose to write this plugin, [check out this blog post](https://morphatic.com/2019/04/14/authorizing-feathers-api-requests-for-vue-react-angular-apps-using-auth0/).

## Who should NOT use this middleware

If any of the following scenarios apply to your app, there are likely better options than this middleware:

* If you are using FeathersJS as **BOTH** frontend and backend, you're probably much better off using the [`@feathersjs/authentication`](https://docs.feathersjs.com/api/authentication/server.html) that's already part of the framework.
* If your access tokens are signed with the `HS256` algorithm (see: [How can I check the signature algorithm?](https://auth0.com/docs/api-auth/tutorials/verify-access-token#check-the-signature-algorithm)), there are easier ways to configure Feathers to verify them.

## Installation and Configuration

To install this package, from the root of your package:

```console
npm install --save @morphatic/feathers-auth0-authorize
```

After installation, you need to make sure that you have a `users` service.

### Add Auth0 domain to server config

In your server config file (usually `config/default.json`), you'll need to add the following:

```json
{
  "auth0domain": "example"
}
```

The package assumes that your full Auth0 domain name is something like `https://example.auth0.com/`. You should only add the "example" part to your config.

### Set up the `users` service

It's likely that you already have a `users` service in your app. If you don't you'll need to create one, e.g. by [using the `feathers-plus` generator](https://generator.feathers-plus.com/get-started/#generate-service). Assuming you already have a `users` service, you'll need to ensure that your model has two string properties: `user_id` and `currentToken`. `user_id` will hold the `user_id` generated by Auth0 when the user's account was created. `currentToken` will be used to store already-verified tokens, to prevent the app from having to re-verify tokens on every request or connection. For reference, [a JSON Schema representation of a minimal `users` service](https://github.com/morphatic/feathers-auth0-authorize/blob/master/test/user-schema.json) is included in this repo.

If you'd like to use a different service for storing the `user_id` and `currentToken`, this is configurable using the `options` described below.

## Basic usage

You'll need to do some configuration on both the server and in your clients.

### Server setup

In your main server configuration (usually `src/app.js`):

```js
// src/app.js

// at the top of the file where everything else gets imported...

// import the middleware generator
const auth0Generator = require('@morphatic/feathers-auth0-authorize')

// extract the part you need
// the `auth0Transports` function enables authorization for REST and Socket.IO
const { auth0Transports } = auth0Generator()

// ... other configuration ...
// if you're using the feathers-plus generators,
// add it in the middleware configuration section

// !code: config_middle
// tell feathers to load it
app.configure(auth0Transports)
// !end

// in any case, it should come BEFORE the 404 handler
app.use(express.notFound()) // <-- BEFORE this line
```

There are many options that make this package highly configurable. These are explained below.

### Client Setup

From your frontend app, you'll need to set up any services that access your feathers API as follows. I've used this in a Vue app, but it should work equally well for any other frontend framework like React or Angular. In this example, I'm imagining that I'm developing the proverbial To Do List app, and that my To Do list items are stored in my feathers backend.

#### REST example

```js
// src/services/feathers.js
import feathers from '@feathersjs/feathers'
import rest from '@feathersjs/rest-client'
import axios from 'axios'

// standard feathers client setup
const app = feathers()
const rc = rest('https://api.example.com') // the URL to your feathers API server
app.configure(rc.axios(axios))

export const api = app

// AFTER authentication against Auth0, you should have
// an access token, which you can add to the api with:

api.rest.defaults.headers.common['Authorization'] = `Bearer ${token}`

// And then api calls can be made as you normally would, e.g.

const todos = await api.service('todos').find({})
```

#### SocketIO example

```js
// src/services/feathers.js
import feathers from '@feathersjs/feathers'
import socketio from '@feathersjs/socketio-client'
import io from 'socket.io-client'

const app = feathers()
const server = io('https://api.example.com') // the URL to your feathers API server

// IMPORTANT: setup the flow for handling authentication
server.on('connect', socket => {
  socket.emit('authenticate', { token })
    .on('authenticated', msg => {
      // do some stuff...
    })
    .on('unauthorized', (err, callback) => {
      if (err.data.type === 'UnauthorizedError' || err.data.code === 'invalid_token') {
        // do some stuff...
      }
    })
})
// then register the transport with your feathers client
app.configure(socketio(server))

export const api = app

// usage is the same as the example above
```

### The `keys` service

In addition, this middleware will generate a `keys` service in your app. This is used to store JSON web keys (JWKs) retrieved from [Auth0's JWKS endpoint](https://auth0.com/docs/jwks). This service does not need to be persistent (the middleware creates an in-memory service) as it is mainly used to cache already-retrieved JWKs and improve performance. Also, although not strictly necessary, since the `keys` service does not contain any non-public information, this middleware sets up a hook to prevent the `keys` service from being called by external clients. For reference, please see [the JSON Schema version of the `keys` service](https://github.com/morphatic/feathers-auth0-authorize/blob/master/test/key-schema.json) contained in this repo.

If you'd like to use a different service for storing the keys, this is configurable using the `options` described below.

## Why not just store the signing certificate on the server

Answer this later.

## Custom Configuration

Remember the "extra" parentheses we had to use when importing the hook into `app.hooks.js` above?

```js
// from src/app.hooks.js in our feathers app
const { authorize } = require('@morphatic/feathers-auth0-authorize')() // <-- NOTE: the "extra" parentheses
```

They're necessary because the function that returns the hook uses [the factory pattern](https://medium.com/javascript-scene/javascript-factory-functions-with-es6-4d224591a8b1) and allows for customization. While you can swap out any of the functions in this plugin for your own implementation, the main things you're likely to want to customize are the services used to hold the `user_id` and `keys`.

### Using a different `users` service

By default, the hook queries the `users` service to find a `user` whose `user_id` matches the Auth0 `user_id` stored in the `sub` claim in the token. However, you might want to store this information on a different model in a different service. To do that, you'd provide an `options` object as a parameter to the `require()()` function and set the `userService` property to the name of the service you want to use. For example, pretend that instead of `users`, you want to look for the `user_id` property on the `members` service instead:

```js
// example src/app.hooks.js with custom `users` service
// first, create an `options` object with the preferred name for your service
const options = {
  userService: 'members'
}
const { authorize } = require('@morphatic/feathers-auth0-authorize')(options) // <-- second, pass it to the import statement
```

That's it!

### Using a different `keys` service

Similarly, you can use a different service name for where you store and look for the JWKs. Here's an example showing customization of BOTH the `users` and `keys` services:

```js
// example src/app.hooks.js with custom `users` service
// first, create an `options` object with the preferred names for your services
const options = {
  userService: 'members',
  keysService: 'jwks'
}
const { authorize } = require('@morphatic/feathers-auth0-authorize')(options) // <-- second, pass it to the import statement
```

## Comments, Questions, Issues, etc

I welcome feedback, bug reports, enhancement requests, or reports on your experiences with the plugin. Undoubtedly, there's a better way to do this than what I've come up with, and I'd love to hear about it. That being said, I hope some people will find this useful!!!
